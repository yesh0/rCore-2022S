# Lab2

## 实现的功能

1. 和 Lab1 差不多的 `sys_task_info` 以及 `sys_get_time` 的实现。
   用了 `translated_byte_buffer`，同时考虑指针指向结构跨页而选择用类似 `memcpy` 而不是直接赋值。
2. `mmap` 方面其实就是把 `PageTable` 的 `map` 和 `unmap` 接口一路暴露出来。
   另外顺便把 `PTEFlags::A` 和 `PTEFlags::D` 设置了。

## 问答作业

### 1. SV39 页表页表项的组成

共八字节，从低到高位分别：
- V：有效的页置 1
- R：可读页面置 1
- W：可写页面置 1
- X：可执行页面置 1
- U：U mode 可用页面置 1
- 另外 RWX 均为零的页表项指向下一级页表，而除此之外的不可读页面似乎还没有具体用法。
- G：是用来减少缓存切换的，如果一个页表项在例如各种内存映射中都相同，则在切换时可以把它的缓存留下。
- A、D：分别为读、写记录位，在读写/写该页面时，如果对应的位为 0，CPU会尝试将其置为 1。
- RSW：保留给操作系统随意使用。
- PPN[0]、PPN[1]、PPN[2]：物理页号。
- 更高位：保留。（现在似乎有 Svnapot 和 Svpbmt 两个扩展在用最高三位。）

### 2. 缺页

- 请问哪些异常可能是缺页导致的？

  - InstructionPageFault：PC 对应指令缺页。
  - LoadPageFault：读缺页。
  - StorePageFault：写缺页。

- 寄存器：

  - scause：异常类型。
  - sstatus：引起异常的特权级。
  - stval：目的地虚拟地址。
  - sepc：引起异常的指令地址。

- 这样做有哪些好处？

  - 加快应用启动时间，减少内存占用。

- 处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存 (估算数量级即可)？

  - 其实可以用 gigapages，只需要一级页表里的 10 * 8 = 80 bytes 就够了。
  - 如果是我们现在的实现的话，只看第三级，10 GB / 4 KB * 8 = 20 MB。

- 请简单思考如何才能实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。

  - 首先我们需要引发缺页异常，这个可能可以直接不初始化页表，或者也可以预先初始化把对应的 PTE 的 U 位置零。
    PTE 中留了两位给操作系统用，所以我们可以用它来区别分页是 swap 了还是 lazy 加载的静态内容
    还是 lazy 分配的请求内存抑或是操作系统用的页面。
  - 当有异常发生时，进行相应操作，例如分配物理内存页面，并对应从硬盘加载内容或是清零等等。

- 此时页面失效如何表现在页表项？

  - 可能可以从 U 位或是 V 位出发？

### 3. 双页表与单页表

- 在单页表情况下，如何更换页表？

  - 在 `__switch` 里切换。
    因为操作系统内部信息（例如每一个任务的 `TaskContext`）在每一个应用页表下都有，所以直接读取下一个应用的页表切换。（当然还要各种现场保存。）

- 单页表情况下，如何控制用户态无法访问内核页面？（tips:看看上一题最后一问）

  - 就是把 PTE 里 U 位置零。

- 单页表有何优势？（回答合理即可）

  - Trap 开销更低，如果把操作系统对应的 PTE 的 G 位设上，那么任务切换的开销也更低。
  - 不需要 Trampoline 了。

- 双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？

  - 双页表：每次 U mode 与 S mode 之间切换时操作系统都需要进行更换操作。
  - 单页表：只有进程切换的时候需要，因为任何操作系统的内容都可以通过当前应用的页表访问。

## 建议

- `TaskStatus` ABI 不一致，已经提了 MR 了（https://github.com/LearningOS/rCore-Tutorial-Code-2022S/pull/5 ）。


    
